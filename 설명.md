# **🎞️ Film Strip AI NLE & 스토리보드 플랫폼 초정밀 로드맵**

이 문서는 CUBE님의 시나리오를 바탕으로 시스템의 아키텍처, 데이터 모델링, 그리고 AI 오케스트레이션 로직을 상세히 다룹니다.

### **1단계: 프론트엔드 \- 랜딩 & 인터랙티브 에디터 (Visual Logic)**

#### **1.1 랜딩 페이지 셰이더 (Shader) 로직**

* **Film Strip Background**: Three.js의 PlaneGeometry에 무한 루프 텍스처를 매핑. uTime 변수를 이용해 고속 이동 구현.  
* **Film Grain Effect**: Fragment Shader에서 Simplex Noise를 중첩시켜 불규칙한 노이즈와 먼지(Dust), 긁힘(Scratch) 효과를 생성하여 로고 뒤에 오버레이.  
* **Scroll Interaction**: Intersection Observer API를 사용하여 특정 섹션 도달 시 랜딩 애니메이션에서 대시보드 설명으로 부드럽게 전환.

#### **1.2 에디터 UI & 레이어 시스템**

* **Canvas & Layer (20x20)**:  
  * 각 캔버스는 하나의 'Scene'을 의미.  
  * Z-index 기반의 레이어 시스템 구축. (아티스트 친화적인 드래그 앤 드롭 레이어 순서 변경)  
* **Camera Motion Preview**: 미리 정의된 카메라 워크(Dolly, Pan, Orbit 등)를 hover 시 작은 \<video\> 혹은 Lottie 애니메이션으로 재생하여 직관성 제공.

### **2단계: 데이터베이스 & 스토리지 아키텍처 (Data Modeling)**

#### **2.1 상세 DB 스키마 (Relational)**

* **Users**: plan\_type (Free/Paid), remaining\_credits, storage\_usage.  
* **Projects**: id, user\_id, working\_mode (Picture/Movie), folder\_structure (Linked to S3).  
* **Canvas\_Layers**:  
  * canvas\_id, layer\_id, content\_data (이미지 경로, 프롬프트, 시드).  
  * metadata: 대사, 분위기, 행동, 카메라 움직임(Enum).  
* **History (Undo/Redo)**:  
  * Action 기반 스택: \[ { action: 'MOVE\_LAYER', prev: x, curr: y }, ... \].  
  * 무거운 데이터 대신 JSON 형태의 \*\*Delta(차이점)\*\*만 저장.

#### **2.2 스토리지 분리 로직**

* **Picture Folder**: 작업 중인 레이어 소스 및 콘티 이미지 (가벼운 WebP 포맷).  
* **Movie Folder**: 생성된 MP4 원본 및 업스케일링 결과물 (고화질 ProRes/H.264).  
* **Auto-Save**: 유저가 수치를 변경할 때마다 Debounce(500ms)를 적용하여 백엔드에 자동 저장 요청.

### **3단계: 백엔드 \- GPU 라우팅 & AI 워크플로우 (Orchestration)**

#### **3.1 등급별 GPU 할당 로직 (Routing)**

* **Free Plan (Local/Home Server)**:  
  * Redis 기반의 Job Queue 생성.  
  * CUBE님의 로컬 서버(ComfyUI)에 Worker를 상주시켜 한 번에 하나씩(Sequential) 처리.  
* **Paid Plan (Cloud API)**:  
  * RunPod 또는 Modal API 연결.  
  * 사용자 요청 시 즉시 인스턴스를 할당하거나 전용 API 서버로 다중 큐(Parallel) 처리.  
  * **Credit Logic**: Total\_Frames x Resolution\_Multiplier \- Batch\_Discount.

#### **3.2 "자동 전체 영화 만들기" 로직**

1. **Visual Analysis**: 각 씬의 이미지를 Gemini 2.5 Flash Vision API로 전송.  
2. **Scene Understanding**: LLM이 이미지의 구도, 캐릭터, 배경을 분석하여 "영상용 상세 프롬프트" 생성.  
3. **Prompt Injection**: 유저가 입력한 "대사", "분위기"를 LLM 프롬프트와 병합.  
4. **Workflow Generation**: ComfyUI API용 JSON 파일을 동적으로 생성하여 영상화 프로세스 시작.

### **4단계: 영상 편집 엔진 \- '가위' 툴 및 합성 (NLE Engine)**

#### **4.1 비선형 편집 로직 (NLE)**

* **Scissors Tool (Cutting)**:  
  * 드래그 영역의 Start\_Frame과 End\_Frame 좌표 추출.  
  * 삭제 요청 시: 해당 구간의 메타데이터를 별도 Trash\_Stack으로 이동.  
* **Auto-Stitch (자동 이어붙이기)**:  
  * 삭제된 빈 공간을 뒤의 프레임들이 X-axis 상으로 자동 이동(Snap).  
  * 연결 부위에 기본 Fade-out 트랜지션 레이어 삽입.  
* **Audio/Sub Layer**: 영상 트랙 위에 별도의 AudioContext 및 TextCanvas 레이어를 겹쳐서 실시간 프리뷰 구현.

#### **4.2 영상 생성 후처리**

* **Upscaling API**: 기본 생성이 완료되면 고성능 업스케일러(ESRGAN 등) API를 호출하여 해상도 뻥튀기.  
* **Final Export**: FFmpeg WASM을 브라우저에서 실행하거나, 서버에서 FFmpeg로 모든 소스(영상+음성+자막)를 합성하여 최종 MP4 출력.

### **5단계: 커뮤니티 & 필모그래피 (Social Expansion)**

* **Public Link**: 프로젝트 완료 후 'Publish' 버튼 클릭 시, 고유한 포트폴리오 URL 생성 (/portfolio/cube-action-01).  
* **Metadata Sharing**: 다른 유저가 해당 영상의 콘티 구조(프롬프트 등)를 참고할 수 있도록 'Show Script' 기능 제공.  
* **Engagement**: 좋아요, 댓글, 그리고 사용된 커스텀 워크플로우 공유 기능.

## **🛠️ 기술적 도전 과제 & 해결책**

1. **Ctrl \+ Z (Undo) 성능**: 캔버스 20개에 레이어 20개면 상태값이 매우 큽니다. Immutable.js를 사용하거나, DB에서 Action-Sourcing 패턴을 사용하여 상태의 히스토리를 추적해야 합니다.  
2. **브라우저 내 대용량 영상 처리**: 전체 영상을 매번 렌더링하면 브라우저가 멈춥니다. 편집 시에는 저화질 'Proxy' 영상을 사용하고, 최종 저장 시에만 서버에서 고화질 합성을 수행하세요.  
3. **ComfyUI 다중 제어**: 유료 유저의 다중 큐 처리를 위해 백엔드에서 API\_KEY 기반의 로드 밸런싱이 필수입니다.