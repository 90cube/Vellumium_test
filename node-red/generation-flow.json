[
    {
        "id": "vellumium-generation-flow",
        "type": "tab",
        "label": "Generation Pipeline",
        "disabled": false,
        "info": "Polls Supabase generation_queue for pending jobs, calls app_engine.py, uploads to R2, updates status.",
        "env": [
            { "name": "SUPABASE_URL", "type": "str", "value": "" },
            { "name": "SUPABASE_SERVICE_ROLE_KEY", "type": "str", "value": "" },
            { "name": "APP_ENGINE_URL", "type": "str", "value": "http://localhost:7860" },
            { "name": "R2_ENDPOINT", "type": "str", "value": "" },
            { "name": "R2_BUCKET", "type": "str", "value": "vellumium-storage" },
            { "name": "R2_ACCESS_KEY_ID", "type": "str", "value": "" },
            { "name": "R2_SECRET_ACCESS_KEY", "type": "str", "value": "" },
            { "name": "R2_PUBLIC_URL", "type": "str", "value": "" }
        ]
    },
    {
        "id": "comment-pipeline",
        "type": "comment",
        "z": "vellumium-generation-flow",
        "name": "=== GENERATION PIPELINE ===",
        "info": "Flow 1: Poll Supabase -> Generate -> Upload R2 -> Update status\n\n1. Timer polls every 5s\n2. Checks concurrency lock (1 GPU job at a time)\n3. Fetches oldest pending job from generation_queue\n4. Updates status to 'processing'\n5. Calls app_engine.py Gradio API\n6. Uploads result to Cloudflare R2 (AWS SigV4)\n7. Updates status to 'completed' with result_url\n8. Updates layer content_url if layer_id present\n9. On any error: updates status to 'failed'\n\nCredentials: Set via flow environment variables (double-click the tab header).\n  - SUPABASE_URL\n  - SUPABASE_SERVICE_ROLE_KEY\n  - APP_ENGINE_URL (default: http://localhost:7860)\n  - R2_ENDPOINT\n  - R2_BUCKET\n  - R2_ACCESS_KEY_ID\n  - R2_SECRET_ACCESS_KEY\n  - R2_PUBLIC_URL (optional, for public-facing result URLs)",
        "x": 180,
        "y": 40,
        "wires": []
    },
    {
        "id": "poll-timer",
        "type": "inject",
        "z": "vellumium-generation-flow",
        "name": "Poll every 5s",
        "props": [{ "p": "payload" }],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": "3",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 100,
        "wires": [["check-lock"]]
    },
    {
        "id": "check-lock",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Check concurrency lock",
        "func": "// Only allow 1 job at a time (GPU is shared)\nvar processing = flow.get('processing') || false;\nif (processing) {\n    return null; // Skip this poll cycle\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "flow.set('processing', false);",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 100,
        "wires": [["set-fetch-headers"]]
    },
    {
        "id": "set-fetch-headers",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Set Supabase fetch headers",
        "func": "const supabaseUrl = env.get('SUPABASE_URL');\nconst serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\n\nif (!supabaseUrl || !serviceKey) {\n    node.status({fill:'red', shape:'ring', text:'Missing config'});\n    return null;\n}\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue?status=eq.pending&order=created_at.asc&limit=1';\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 100,
        "wires": [["fetch-pending-job"]]
    },
    {
        "id": "fetch-pending-job",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "GET pending jobs",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 810,
        "y": 100,
        "wires": [["extract-job"]]
    },
    {
        "id": "extract-job",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Extract job or stop",
        "func": "if (!Array.isArray(msg.payload) || msg.payload.length === 0) {\n    return null; // No pending jobs\n}\n\nconst job = msg.payload[0];\nmsg.job = job;\nnode.status({fill:'blue', shape:'dot', text:'Job ' + job.id.substring(0,8) + '...'});\nnode.warn('[Generation] Starting job: ' + job.id);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 100,
        "wires": [["set-processing-lock"]]
    },
    {
        "id": "set-processing-lock",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Acquire lock",
        "func": "flow.set('processing', true);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 100,
        "wires": [["update-status-processing"]]
    },
    {
        "id": "update-status-processing",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build PATCH: status=processing",
        "func": "const supabaseUrl = env.get('SUPABASE_URL');\nconst serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst jobId = msg.job.id;\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue?id=eq.' + jobId;\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\nmsg.method = 'PATCH';\nmsg.payload = {\n    status: 'processing',\n    updated_at: new Date().toISOString()\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 220,
        "wires": [["patch-processing"]]
    },
    {
        "id": "patch-processing",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "PATCH status=processing",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 450,
        "y": 220,
        "wires": [["build-generation-request"]]
    },
    {
        "id": "build-generation-request",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build Gradio API request",
        "func": "const job = msg.job;\nconst params = job.params || {};\nconst appEngineUrl = env.get('APP_ENGINE_URL') || 'http://localhost:7860';\n\n// Extract generation parameters with defaults\nconst prompt = job.prompt || '';\nconst height = params.height || 1024;\nconst width = params.width || 1024;\nconst steps = params.steps || 8;\nconst seed = (params.seed !== undefined && params.seed !== null) ? params.seed : -1;\nconst controlType = params.control_type || 'None';\nconst controlScale = (params.control_scale !== undefined && params.control_scale !== null) ? params.control_scale : 0.75;\n\n// Gradio API call format\n// The generate button (gen_btn) is connected to do_generate\n// Inputs order from app_engine.py gen_btn.click:\n//   prompt, input_image, steps, height, width,\n//   control_image, control_type, control_scale,\n//   mask_image, seed, scheduler,\n//   mask_blur, denoise_strength, ...lora_sliders\nmsg.url = appEngineUrl + '/api/predict';\nmsg.method = 'POST';\nmsg.headers = {\n    'Content-Type': 'application/json'\n};\n\nmsg.payload = {\n    fn_index: 0,\n    data: [\n        prompt,          // prompt\n        null,            // input_image (None for t2i)\n        steps,           // steps\n        height,          // height\n        width,           // width\n        null,            // control_image (None)\n        controlType,     // control_type\n        controlScale,    // control_scale\n        null,            // mask_image (None)\n        seed,            // seed\n        'res_multistep', // scheduler\n        12,              // mask_blur\n        1.0              // denoise_strength\n    ],\n    session_hash: 'nodered_' + job.id.substring(0, 8)\n};\n\nnode.warn('[Generation] Calling app_engine: prompt=\"' + prompt.substring(0, 50) + '...\", ' + width + 'x' + height + ', steps=' + steps);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 220,
        "wires": [["call-app-engine"]]
    },
    {
        "id": "call-app-engine",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "POST app_engine generate",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "timeout": "120000",
        "x": 960,
        "y": 220,
        "wires": [["process-generation-result"], ["handle-generation-error"]]
    },
    {
        "id": "process-generation-result",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Extract image from Gradio response",
        "func": "// Gradio API response formats:\n// 1. { data: [{ path: \"...\", url: \"...\", ... }] }  (file reference)\n// 2. { data: [\"data:image/png;base64,...\"] }          (base64)\n// 3. { data: [{ is_file: true, name: \"...\", ... }] } (older gradio)\n\nconst response = msg.payload;\n\nif (!response || !response.data || response.data.length === 0) {\n    node.error('Empty response from app_engine');\n    msg.error_message = 'Empty response from app_engine generation API';\n    return [null, msg];\n}\n\nconst result = response.data[0];\n\nif (typeof result === 'string' && result.startsWith('data:image')) {\n    // Base64 encoded image\n    var base64Data = result.split(',')[1];\n    msg.imageBuffer = Buffer.from(base64Data, 'base64');\n    msg.imageContentType = 'image/png';\n    node.warn('[Generation] Got base64 image from app_engine');\n    return [msg, null];\n} else if (result && result.url) {\n    // File URL - need to fetch it\n    msg.imageFileUrl = result.url;\n    node.warn('[Generation] Got file URL: ' + result.url);\n    return [msg, null];\n} else if (result && result.path) {\n    // Local file path - construct Gradio file URL\n    var appEngineUrl = env.get('APP_ENGINE_URL') || 'http://localhost:7860';\n    msg.imageFileUrl = appEngineUrl + '/file=' + result.path;\n    node.warn('[Generation] Got file path: ' + result.path);\n    return [msg, null];\n} else {\n    node.error('Unexpected response format from app_engine');\n    msg.error_message = 'Unexpected response format: ' + JSON.stringify(result).substring(0, 200);\n    return [null, msg];\n}",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 340,
        "wires": [["check-need-fetch-image"], ["update-status-failed"]]
    },
    {
        "id": "check-need-fetch-image",
        "type": "switch",
        "z": "vellumium-generation-flow",
        "name": "Has buffer already?",
        "property": "imageBuffer",
        "propertyType": "msg",
        "rules": [
            { "t": "nnull" },
            { "t": "null" }
        ],
        "checkall": "false",
        "repair": false,
        "outputs": 2,
        "x": 540,
        "y": 340,
        "wires": [["build-r2-upload"], ["set-fetch-image-url"]]
    },
    {
        "id": "set-fetch-image-url",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Set image fetch URL",
        "func": "msg.url = msg.imageFileUrl;\nmsg.method = 'GET';\ndelete msg.headers;\ndelete msg.payload;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 380,
        "wires": [["fetch-image-file"]]
    },
    {
        "id": "fetch-image-file",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "Fetch image from Gradio file server",
        "method": "GET",
        "ret": "bin",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1010,
        "y": 380,
        "wires": [["convert-fetched-image"]]
    },
    {
        "id": "convert-fetched-image",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Store image buffer",
        "func": "msg.imageBuffer = msg.payload;\nmsg.imageContentType = 'image/png';\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 380,
        "wires": [["build-r2-upload"]]
    },
    {
        "id": "build-r2-upload",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build R2 upload (AWS SigV4)",
        "func": "// AWS Signature V4 signing for Cloudflare R2\n// R2 is S3-compatible, uses standard AWS SigV4\n\nconst crypto = global.get('crypto') || require('crypto');\n\nconst accessKeyId = env.get('R2_ACCESS_KEY_ID');\nconst secretAccessKey = env.get('R2_SECRET_ACCESS_KEY');\nconst endpoint = env.get('R2_ENDPOINT');\nconst bucket = env.get('R2_BUCKET');\n\nif (!accessKeyId || !secretAccessKey || !endpoint) {\n    msg.error_message = 'R2 credentials not configured (R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, R2_ENDPOINT)';\n    node.error(msg.error_message);\n    return msg;\n}\n\nconst job = msg.job;\nconst userId = job.user_id || 'anonymous';\nconst sceneId = job.scene_id || 'misc';\nconst layerId = job.layer_id || 'gen';\nconst timestamp = Date.now();\nconst objectKey = 'generations/' + userId + '/' + sceneId + '/' + layerId + '/' + timestamp + '.png';\n\n// Parse the endpoint hostname\nvar host;\ntry {\n    var endpointUrl = new URL(endpoint);\n    host = endpointUrl.hostname;\n} catch(e) {\n    // Fallback: extract hostname manually\n    host = endpoint.replace(/^https?:\\/\\//, '').split('/')[0];\n}\n\nvar region = 'auto'; // R2 uses 'auto'\nvar service = 's3';\n\n// Current time in ISO format for AWS\nvar now = new Date();\nvar amzDate = now.toISOString().replace(/[:\\-]|\\.\\d{3}/g, '');\nvar dateStamp = amzDate.substring(0, 8);\n\nvar method = 'PUT';\nvar canonicalUri = '/' + bucket + '/' + objectKey;\nvar canonicalQueryString = '';\n\nvar payloadHash = crypto.createHash('sha256').update(msg.imageBuffer).digest('hex');\n\nvar canonicalHeaders =\n    'content-type:image/png\\n' +\n    'host:' + host + '\\n' +\n    'x-amz-content-sha256:' + payloadHash + '\\n' +\n    'x-amz-date:' + amzDate + '\\n';\n\nvar signedHeaders = 'content-type;host;x-amz-content-sha256;x-amz-date';\n\nvar canonicalRequest = [\n    method,\n    canonicalUri,\n    canonicalQueryString,\n    canonicalHeaders,\n    signedHeaders,\n    payloadHash\n].join('\\n');\n\nvar algorithm = 'AWS4-HMAC-SHA256';\nvar credentialScope = dateStamp + '/' + region + '/' + service + '/aws4_request';\nvar stringToSign = [\n    algorithm,\n    amzDate,\n    credentialScope,\n    crypto.createHash('sha256').update(canonicalRequest).digest('hex')\n].join('\\n');\n\nfunction hmacSHA256(key, data) {\n    return crypto.createHmac('sha256', key).update(data).digest();\n}\n\nvar kDate = hmacSHA256('AWS4' + secretAccessKey, dateStamp);\nvar kRegion = hmacSHA256(kDate, region);\nvar kService = hmacSHA256(kRegion, service);\nvar kSigning = hmacSHA256(kService, 'aws4_request');\n\nvar signature = crypto.createHmac('sha256', kSigning)\n    .update(stringToSign)\n    .digest('hex');\n\nvar authHeader = algorithm + ' Credential=' + accessKeyId + '/' + credentialScope + ', SignedHeaders=' + signedHeaders + ', Signature=' + signature;\n\n// Build result URL\nvar r2PublicUrl = env.get('R2_PUBLIC_URL');\nif (r2PublicUrl) {\n    msg.resultUrl = r2PublicUrl + '/' + objectKey;\n} else {\n    msg.resultUrl = endpoint + '/' + bucket + '/' + objectKey;\n}\nmsg.r2ObjectKey = objectKey;\n\n// Set up HTTP request\nmsg.url = endpoint + '/' + bucket + '/' + objectKey;\nmsg.method = 'PUT';\nmsg.headers = {\n    'Content-Type': 'image/png',\n    'Host': host,\n    'x-amz-content-sha256': payloadHash,\n    'x-amz-date': amzDate,\n    'Authorization': authHeader\n};\nmsg.payload = msg.imageBuffer;\n\nnode.warn('[Generation] Uploading to R2: ' + objectKey);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 460,
        "wires": [["upload-to-r2"]]
    },
    {
        "id": "upload-to-r2",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "PUT image to R2",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 560,
        "y": 460,
        "wires": [["check-r2-response"], ["handle-r2-error"]]
    },
    {
        "id": "check-r2-response",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Verify R2 upload success",
        "func": "if (msg.statusCode >= 200 && msg.statusCode < 300) {\n    node.warn('[Generation] R2 upload successful: ' + msg.r2ObjectKey);\n    return msg;\n} else {\n    node.error('R2 upload failed with status ' + msg.statusCode + ': ' + msg.payload);\n    msg.error_message = 'R2 upload failed: HTTP ' + msg.statusCode;\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 460,
        "wires": [["update-status-completed"]]
    },
    {
        "id": "handle-r2-error",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "R2 upload error",
        "func": "msg.error_message = 'R2 upload error: ' + (msg.payload || 'Unknown error');\nnode.error(msg.error_message);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 500,
        "wires": [["update-status-failed"]]
    },
    {
        "id": "update-status-completed",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build PATCH: status=completed",
        "func": "var supabaseUrl = env.get('SUPABASE_URL');\nvar serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\nvar jobId = msg.job.id;\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue?id=eq.' + jobId;\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\nmsg.method = 'PATCH';\nmsg.payload = {\n    status: 'completed',\n    result_url: msg.resultUrl,\n    updated_at: new Date().toISOString()\n};\n\nnode.warn('[Generation] Job ' + jobId + ' completed. Result: ' + msg.resultUrl);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 580,
        "wires": [["patch-completed"]]
    },
    {
        "id": "patch-completed",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "PATCH status=completed",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 470,
        "y": 580,
        "wires": [["update-layer-content"]]
    },
    {
        "id": "update-layer-content",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build PATCH: layer content_url",
        "func": "var job = msg.job;\n\n// Only update layer if layer_id is present\nif (!job.layer_id) {\n    node.warn('[Generation] No layer_id, skipping layer update');\n    return [null, msg]; // Output 2 -> release-lock\n}\n\nvar supabaseUrl = env.get('SUPABASE_URL');\nvar serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\n\nmsg.url = supabaseUrl + '/rest/v1/layers?id=eq.' + job.layer_id;\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\nmsg.method = 'PATCH';\nmsg.payload = {\n    content_url: msg.resultUrl\n};\n\nnode.warn('[Generation] Updating layer ' + job.layer_id + ' content_url');\n\nreturn [msg, null]; // Output 1 -> patch-layer",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 720,
        "y": 580,
        "wires": [["patch-layer"], ["release-lock"]]
    },
    {
        "id": "patch-layer",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "PATCH layer content_url",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 970,
        "y": 580,
        "wires": [["release-lock"]]
    },
    {
        "id": "release-lock",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Release lock",
        "func": "flow.set('processing', false);\nnode.status({fill:'green', shape:'dot', text:'Idle - ready'});\nnode.warn('[Generation] Job complete, lock released');\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 580,
        "wires": [[]]
    },
    {
        "id": "handle-generation-error",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Generation API error",
        "func": "var errorDetail = msg.payload ?\n    (typeof msg.payload === 'string' ? msg.payload : JSON.stringify(msg.payload)) :\n    'Unknown error from app_engine';\nmsg.error_message = 'Generation failed: HTTP ' + (msg.statusCode || 'N/A') + ' - ' + errorDetail.substring(0, 500);\nnode.error(msg.error_message);\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 230,
        "y": 280,
        "wires": [["update-status-failed"]]
    },
    {
        "id": "update-status-failed",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Build PATCH: status=failed",
        "func": "var supabaseUrl = env.get('SUPABASE_URL');\nvar serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\nvar jobId = msg.job ? msg.job.id : null;\nvar errorMessage = msg.error_message || 'Unknown error';\n\nif (!jobId) {\n    node.error('[Generation] Cannot update status: no job ID');\n    flow.set('processing', false);\n    return null;\n}\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue?id=eq.' + jobId;\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\nmsg.method = 'PATCH';\nmsg.payload = {\n    status: 'failed',\n    error_message: errorMessage.substring(0, 1000),\n    updated_at: new Date().toISOString()\n};\n\nnode.error('[Generation] Job ' + jobId + ' FAILED: ' + errorMessage);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 680,
        "wires": [["patch-failed"]]
    },
    {
        "id": "patch-failed",
        "type": "http request",
        "z": "vellumium-generation-flow",
        "name": "PATCH status=failed",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 790,
        "y": 680,
        "wires": [["release-lock-on-error"]]
    },
    {
        "id": "release-lock-on-error",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Release lock (error path)",
        "func": "flow.set('processing', false);\nnode.status({fill:'red', shape:'ring', text:'Last job failed'});\nnode.warn('[Generation] Lock released after error');\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 680,
        "wires": [[]]
    },
    {
        "id": "catch-all-errors",
        "type": "catch",
        "z": "vellumium-generation-flow",
        "name": "Catch all errors",
        "scope": null,
        "uncaught": false,
        "x": 140,
        "y": 760,
        "wires": [["error-handler"]]
    },
    {
        "id": "error-handler",
        "type": "function",
        "z": "vellumium-generation-flow",
        "name": "Global error handler",
        "func": "node.error('[Generation] Uncaught error: ' + (msg.error ? msg.error.message : 'unknown'));\n\n// Try to update job status if we have job info\nif (msg.job && msg.job.id) {\n    msg.error_message = 'Uncaught error: ' + (msg.error ? msg.error.message : 'unknown');\n    return msg;\n}\n\n// No job context, just release the lock\nflow.set('processing', false);\nnode.status({fill:'red', shape:'ring', text:'Error (no job ctx)'});\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 760,
        "wires": [["update-status-failed"]]
    },

    {
        "id": "health-check-flow",
        "type": "tab",
        "label": "Health Check",
        "disabled": false,
        "info": "Health check dashboard endpoints",
        "env": [
            { "name": "APP_ENGINE_URL", "type": "str", "value": "http://localhost:7860" },
            { "name": "SUPABASE_URL", "type": "str", "value": "" },
            { "name": "SUPABASE_SERVICE_ROLE_KEY", "type": "str", "value": "" },
            { "name": "R2_ENDPOINT", "type": "str", "value": "" },
            { "name": "R2_BUCKET", "type": "str", "value": "vellumium-storage" }
        ]
    },
    {
        "id": "comment-health",
        "type": "comment",
        "z": "health-check-flow",
        "name": "=== HEALTH CHECK DASHBOARD ===",
        "info": "Flow 2: Health check endpoints\n\nGET /api/health - Overall system status (config check)\nGET /api/health/app-engine - Live check if app_engine.py is running",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "health-http-in",
        "type": "http in",
        "z": "health-check-flow",
        "name": "GET /api/health",
        "url": "/api/health",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 120,
        "wires": [["health-check-function"]]
    },
    {
        "id": "health-check-function",
        "type": "function",
        "z": "health-check-flow",
        "name": "Check all services",
        "func": "var appEngineUrl = env.get('APP_ENGINE_URL') || 'http://localhost:7860';\n\nvar healthReport = {\n    node_red: {\n        status: 'ok',\n        uptime_seconds: Math.floor(process.uptime())\n    },\n    generation_pipeline: {\n        processing: flow.get('processing') || false\n    },\n    config: {\n        supabase_url: env.get('SUPABASE_URL') ? 'configured' : 'MISSING',\n        supabase_key: env.get('SUPABASE_SERVICE_ROLE_KEY') ? 'configured' : 'MISSING',\n        app_engine_url: appEngineUrl,\n        r2_endpoint: env.get('R2_ENDPOINT') ? 'configured' : 'MISSING',\n        r2_bucket: env.get('R2_BUCKET') || 'NOT SET'\n    },\n    timestamp: new Date().toISOString()\n};\n\nmsg.payload = healthReport;\nmsg.statusCode = 200;\nmsg.headers = { 'Content-Type': 'application/json' };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 390,
        "y": 120,
        "wires": [["health-http-out"]]
    },
    {
        "id": "health-http-out",
        "type": "http response",
        "z": "health-check-flow",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 610,
        "y": 120,
        "wires": []
    },
    {
        "id": "health-app-engine-in",
        "type": "http in",
        "z": "health-check-flow",
        "name": "GET /api/health/app-engine",
        "url": "/api/health/app-engine",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 190,
        "y": 220,
        "wires": [["build-app-engine-health-check"]]
    },
    {
        "id": "build-app-engine-health-check",
        "type": "function",
        "z": "health-check-flow",
        "name": "Build app_engine health request",
        "func": "var appEngineUrl = env.get('APP_ENGINE_URL') || 'http://localhost:7860';\nmsg.url = appEngineUrl + '/health';\nmsg.method = 'GET';\nmsg._originalReq = msg.req;\nmsg._originalRes = msg.res;\ndelete msg.headers;\ndelete msg.payload;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 220,
        "wires": [["check-app-engine-health"]]
    },
    {
        "id": "check-app-engine-health",
        "type": "http request",
        "z": "health-check-flow",
        "name": "GET app_engine /health",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 730,
        "y": 220,
        "wires": [["app-engine-health-ok"], ["app-engine-health-fail"]]
    },
    {
        "id": "app-engine-health-ok",
        "type": "function",
        "z": "health-check-flow",
        "name": "App engine OK",
        "func": "msg.req = msg._originalReq;\nmsg.res = msg._originalRes;\nmsg.payload = {\n    app_engine: {\n        status: 'ok',\n        response: msg.payload\n    },\n    timestamp: new Date().toISOString()\n};\nmsg.statusCode = 200;\nmsg.headers = { 'Content-Type': 'application/json' };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 200,
        "wires": [["health-app-engine-out"]]
    },
    {
        "id": "app-engine-health-fail",
        "type": "function",
        "z": "health-check-flow",
        "name": "App engine DOWN",
        "func": "msg.req = msg._originalReq;\nmsg.res = msg._originalRes;\nmsg.payload = {\n    app_engine: {\n        status: 'down',\n        error: msg.payload || 'Connection refused'\n    },\n    timestamp: new Date().toISOString()\n};\nmsg.statusCode = 503;\nmsg.headers = { 'Content-Type': 'application/json' };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 240,
        "wires": [["health-app-engine-out"]]
    },
    {
        "id": "health-app-engine-out",
        "type": "http response",
        "z": "health-check-flow",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {},
        "x": 1190,
        "y": 220,
        "wires": []
    },

    {
        "id": "manual-test-flow",
        "type": "tab",
        "label": "Manual Test",
        "disabled": false,
        "info": "Manual testing tools for the generation pipeline",
        "env": [
            { "name": "SUPABASE_URL", "type": "str", "value": "" },
            { "name": "SUPABASE_SERVICE_ROLE_KEY", "type": "str", "value": "" }
        ]
    },
    {
        "id": "comment-test",
        "type": "comment",
        "z": "manual-test-flow",
        "name": "=== MANUAL TESTING ===",
        "info": "Manual test tools:\n1. Insert a sample generation job into Supabase\n2. Check the current queue status\n\nNote: The test job insert uses the service role key which bypasses RLS.\nThe sample job omits user_id. If user_id has a NOT NULL constraint,\nupdate the test function to include a valid user_id.",
        "x": 170,
        "y": 40,
        "wires": []
    },
    {
        "id": "test-inject",
        "type": "inject",
        "z": "manual-test-flow",
        "name": "Test: Insert sample job",
        "props": [{ "p": "payload" }],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 120,
        "wires": [["test-build-insert"]]
    },
    {
        "id": "test-build-insert",
        "type": "function",
        "z": "manual-test-flow",
        "name": "Build test job insert",
        "func": "var supabaseUrl = env.get('SUPABASE_URL');\nvar serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\n\nif (!supabaseUrl || !serviceKey) {\n    node.error('SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY not configured. Set them in the flow tab environment variables.');\n    node.status({fill:'red', shape:'ring', text:'Missing config'});\n    return null;\n}\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue';\nmsg.method = 'POST';\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=representation'\n};\nmsg.payload = {\n    prompt: 'A beautiful sunset over a calm ocean, golden light reflecting on water, photorealistic, 8k quality',\n    params: {\n        width: 1024,\n        height: 1024,\n        steps: 8,\n        seed: 42,\n        control_type: 'None',\n        control_scale: 0.75\n    },\n    status: 'pending'\n};\n\nnode.warn('[Test] Inserting sample generation job...');\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 120,
        "wires": [["test-insert-request"]]
    },
    {
        "id": "test-insert-request",
        "type": "http request",
        "z": "manual-test-flow",
        "name": "POST test job to Supabase",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 710,
        "y": 120,
        "wires": [["test-result-debug"]]
    },
    {
        "id": "test-result-debug",
        "type": "debug",
        "z": "manual-test-flow",
        "name": "Test result",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "statusCode",
        "statusType": "msg",
        "x": 930,
        "y": 120,
        "wires": []
    },
    {
        "id": "test-check-queue",
        "type": "inject",
        "z": "manual-test-flow",
        "name": "Test: Check queue status",
        "props": [{ "p": "payload" }],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 220,
        "wires": [["test-build-queue-check"]]
    },
    {
        "id": "test-build-queue-check",
        "type": "function",
        "z": "manual-test-flow",
        "name": "Build queue status query",
        "func": "var supabaseUrl = env.get('SUPABASE_URL');\nvar serviceKey = env.get('SUPABASE_SERVICE_ROLE_KEY');\n\nmsg.url = supabaseUrl + '/rest/v1/generation_queue?select=id,status,prompt,created_at,updated_at,result_url,error_message&order=created_at.desc&limit=10';\nmsg.headers = {\n    'apikey': serviceKey,\n    'Authorization': 'Bearer ' + serviceKey,\n    'Content-Type': 'application/json'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 220,
        "wires": [["test-queue-request"]]
    },
    {
        "id": "test-queue-request",
        "type": "http request",
        "z": "manual-test-flow",
        "name": "GET queue status",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 700,
        "y": 220,
        "wires": [["test-queue-debug"]]
    },
    {
        "id": "test-queue-debug",
        "type": "debug",
        "z": "manual-test-flow",
        "name": "Queue status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 930,
        "y": 220,
        "wires": []
    }
]